{"pageProps":{"dir":"553-hard-deep-object-to-unique","id":"553","challenge":"hard","info":{"difficulty":"hard","title":"Deep object to unique","tags":"deep","author":{"github":"uid11","name":null}},"prefix":"<!--info-header-start--><h1>Deep object to unique <img src=\"https://img.shields.io/badge/-hard-de3d37\" alt=\"hard\"/> <img src=\"https://img.shields.io/badge/-%23deep-999\" alt=\"#deep\"/></h1><blockquote><p>by null <a href=\"https://github.com/uid11\" target=\"_blank\">@uid11</a></p></blockquote><p><a href=\"https://tsch.js.org/553/play\" target=\"_blank\"><img src=\"https://img.shields.io/badge/-Take%20the%20Challenge-3178c6?logo=typescript&logoColor=white\" alt=\"Take the Challenge\"/></a> &nbsp;&nbsp;&nbsp;<a href=\"./README.ja.md\" target=\"_blank\"><img src=\"https://img.shields.io/badge/-%E6%97%A5%E6%9C%AC%E8%AA%9E-gray\" alt=\"日本語\"/></a> </p><!--info-header-end-->\n\nTypeScript has structural type system, but sometimes you want a function to accept only some previously well-defined unique objects (as in the nominal type system), and not any objects that have the required fields.\r\n\r\nCreate a type that takes an object and makes it and all deeply nested objects in it unique, while preserving the string and numeric keys of all objects, and the values of all properties on these keys.\r\n\r\nThe original type and the resulting unique type must be mutually assignable, but not identical. \r\n\r\nFor example,\r\n\r\n```ts\r\nimport { Equal } from \"@type-challenges/utils\"\r\n\r\ntype Foo = { foo: 2; bar: { 0: 1 }; baz: { 0: 1 } }\r\n\r\ntype UniqFoo = DeepObjectToUniq<Foo>\r\n\r\ndeclare let foo: Foo\r\ndeclare let uniqFoo: UniqFoo\r\n\r\nuniqFoo = foo // ok\r\nfoo = uniqFoo // ok\r\n\r\ntype T0 = Equal<UniqFoo, Foo> // false\r\ntype T1 = UniqFoo[\"foo\"] // 2\r\ntype T2 = Equal<UniqFoo[\"bar\"], UniqFoo[\"baz\"]> // false\r\ntype T3 = UniqFoo[\"bar\"][0] // 1\r\ntype T4 = Equal<keyof Foo & string, keyof UniqFoo & string> // true\r\n```\n\n\n<!--info-footer-start--><br><a href=\"../../README.md\" target=\"_blank\"><img src=\"https://img.shields.io/badge/-Back-grey\" alt=\"Back\"/></a> <a href=\"https://tsch.js.org/553/answer\" target=\"_blank\"><img src=\"https://img.shields.io/badge/-Share%20your%20Solutions-teal\" alt=\"Share your Solutions\"/></a> <a href=\"https://tsch.js.org/553/solutions\" target=\"_blank\"><img src=\"https://img.shields.io/badge/-Check%20out%20Solutions-de5a77?logo=awesome-lists&logoColor=white\" alt=\"Check out Solutions\"/></a> <!--info-footer-end-->","suffix":"import { Equal, IsTrue, IsFalse } from \"@type-challenges/utils\"\r\n\r\ntype Quz = { quz: 4 }\r\n\r\ntype Foo = { foo: 2; baz: Quz; bar: Quz }\r\ntype Bar = { foo: 2; baz: Quz; bar: Quz & { quzz?: 0 } }\r\n\r\ntype UniqFoo = DeepObjectToUniq<Foo>\r\ntype UniqBar = DeepObjectToUniq<Bar>\r\n\r\ndeclare let foo: Foo\r\ndeclare let uniqFoo: UniqFoo\r\n\r\nuniqFoo = foo\r\nfoo = uniqFoo\r\n\r\ntype cases = [\r\n  IsFalse<Equal<UniqFoo, Foo>>,\r\n  IsTrue<Equal<UniqFoo[\"foo\"], Foo[\"foo\"]>>,\r\n  IsTrue<Equal<UniqFoo[\"bar\"][\"quz\"], Foo[\"bar\"][\"quz\"]>>,\r\n  IsFalse<Equal<UniqFoo[\"bar\"], UniqFoo[\"baz\"]>>,\r\n  IsFalse<Equal<UniqBar[\"baz\"], UniqFoo[\"baz\"]>>,\r\n  IsTrue<Equal<keyof UniqBar[\"baz\"], keyof UniqFoo[\"baz\"]>>,\r\n  IsTrue<Equal<keyof Foo, keyof UniqFoo & string>>\r\n];\n","content":"type DeepObjectToUniq<O extends object> = any\n"},"__N_SSG":true}